@page "/pricebook2/{DraftId:int}"
@using System.Data
@using Microsoft.Data.SqlClient
@using Chapin.PriceBook
@using Microsoft.AspNetCore.Components.Forms
@using Syncfusion.Blazor.RichTextEditor
@using Syncfusion.XlsIO

@inject PcfManager.Services.IPriceBookVersionService VersionService
@inject IConfiguration Config
@inject IWebHostEnvironment Env

<h2>Price Book (v2)</h2>

<InputRadioGroup @bind-Value="Mode" class="pb-3 d-block">
    <div class="form-check">
        <InputRadio class="form-check-input" Value="@("DraftLive")" />
        <label class="form-check-label">Draft Live Preview (uses DraftId + TemplateId)</label>
    </div>
    <div class="form-check">
       <!-- <InputRadio class="form-check-input" Value="@("Version")" />
         <label class="form-check-label">Frozen Version (uses VersionId)</label> -->
    </div>
</InputRadioGroup>

@if (Mode == "DraftLive")
{
    <div class="card p-3 mb-3">
        <div class="row g-2">
            <div class="col-sm-3">
                <label class="form-label">Draft Id</label>
                <input class="form-control" type="number" @bind="DraftId" />
            </div>
            <div class="col-sm-4">
                <label class="form-label">Template</label>
                <select class="form-select" @bind="SelectedTemplateId" @bind:event="onchange" @bind:after="OnTemplateChangedAsync">
                    
                    <option value="">-- select template --</option>
                    @foreach (var t in Templates)
                    {
                        <option value="@t.TemplateId">@t.TemplateName (@t.ExcelFileName)</option>
                    }
                </select>
            </div>
            <div class="col-sm-3 form-check" style="padding-top: 2rem;">
                <input class="form-check-input" type="checkbox" id="forceCurrent" @bind="ForceCurrentOnly" />
                <label class="form-check-label" for="forceCurrent">Force Current (exclude future)</label>
            </div>
            <div class="col-sm-2" style="padding-top: 2rem;">
                <button class="btn btn-primary w-100" @onclick="GenerateFromDraftLiveAsync" disabled="@IsBusy">
                    @if (IsBusy) { <span>Working…</span> } else { <span>Generate</span> }
                </button>
            </div>
        </div>
    </div>
}
else
{
    <div class="card p-3 mb-3">
        <div class="row g-2">
            <div class="col-sm-3">
                <label class="form-label">Version Id</label>
                <input class="form-control" type="number" @bind="VersionId" />
            </div>
            <div class="col-sm-4">
                <label class="form-label">Template (auto from Version)</label>
                <input class="form-control" value="@ResolvedVersionTemplateName" disabled />
            </div>
            <div class="col-sm-3" style="padding-top: 2rem;">
                <button class="btn btn-primary w-100" @onclick="GenerateFromVersionAsync" disabled="@IsBusy">
                    @if (IsBusy) { <span>Working…</span> } else { <span>Generate</span> }
                </button>
            </div>
        </div>
    </div>
}

@if (!string.IsNullOrWhiteSpace(LastOutputRelativePath))
{
    <div class="alert alert-success">
        <div><strong>File ready:</strong> <a href="@LastOutputRelativePath" download>@System.IO.Path.GetFileName(LastOutputRelativePath)</a></div>
        <div class="small text-muted">@LastMessage</div>
    </div>
}
@if (!string.IsNullOrWhiteSpace(ErrorMessage))
{
    <div class="alert alert-danger">
        @ErrorMessage
    </div>
}

<div class="card p-3 mb-3" style="display: @(string.IsNullOrWhiteSpace(TextBox4Content) && string.IsNullOrWhiteSpace(TextBox2Content) ? "none" : "block")">
    <div class="row g-2">

        <div class="col-sm-6">
            <label class="form-label">Terms Text</label>
            <SfRichTextEditor @bind-Value="TextBox2Content" Readonly="true">
                <RichTextEditorInlineMode Enable="true" ShowOnSelection="false" />
            </SfRichTextEditor>
        </div>
        <div class="col-sm-6">
            <label class="form-label">Title Text</label>
            <SfRichTextEditor @bind-Value="TextBox4Content" Readonly="true">
                <RichTextEditorInlineMode Enable="true" ShowOnSelection="false" />
            </SfRichTextEditor>
        </div>
    </div> +

</div>

@code {
    [Parameter] public int DraftId { get; set; }
    // ----- UI State -----
    private string Mode { get; set; } = "DraftLive"; // or "Version"
    //private long DraftId { get; set; }
    private int? SelectedTemplateId { get; set; }
    private bool ForceCurrentOnly { get; set; } = true;

    private long VersionId { get; set; }
    private string? ResolvedVersionTemplateName { get; set; }

    private bool IsBusy { get; set; }
    private string? LastOutputRelativePath { get; set; }
    private string? LastMessage { get; set; }
    private string? ErrorMessage { get; set; }

    private string TextBox4Content { get; set; } = string.Empty;
    private string TextBox2Content { get; set; } = string.Empty;


    // ----- Templates dropdown -----
    private readonly List<TemplateRow> Templates = new();

    private sealed record TemplateRow(int TemplateId, string TemplateName, string ExcelFileName);

    protected override async Task OnInitializedAsync()
    {
        try
        {
            await LoadTemplatesAsync();
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Failed to load templates: {ex.Message}";
        }
    }

    private async Task LoadTemplatesAsync()
    {
        Templates.Clear();

        var connStr = Config.GetConnectionString("CiiSQL10rw")
            ?? throw new InvalidOperationException("Missing connection string 'CiiSQL10rw'.");

        const string sql = @"
SELECT TemplateId, TemplateName, ExcelFileName
FROM dbo.Chap_PriceBookTemplate
ORDER BY TemplateName;";

        await using var conn = new SqlConnection(connStr);
        await conn.OpenAsync();
        await using var cmd = new SqlCommand(sql, conn);
        await using var r = await cmd.ExecuteReaderAsync();
        while (await r.ReadAsync())
        {
            Templates.Add(new TemplateRow(
                r.GetInt32(0),
                r.GetString(1),
                r.GetString(2)
            ));
        }
    }

    // ----- Generate: Draft Live -----
    private async Task GenerateFromDraftLiveAsync()
    {
        ResetOutput();
        if (DraftId <= 0) { ErrorMessage = "Please provide a valid Draft Id."; return; }
        if (SelectedTemplateId is null) { ErrorMessage = "Please select a template."; return; }

        IsBusy = true;
        try
        {
            var connStr = Config.GetConnectionString("CiiSQL10rw")
                ?? throw new InvalidOperationException("Missing connection string 'CiiSQL10rw'.");

            // Resolve Excel template full path
            var (templatePath, templateName) = await ResolveTemplatePathByTemplateIdAsync(connStr, SelectedTemplateId.Value);

            // Extract additional data from template (TextBox 4 and TextBox 2)
            var (textBox4Content, textBox2Content) = await ExtractTextFromTemplateAsync(templatePath);

            // Build sources
            var legacy = new SqlDataSource(connStr); // existing legacy source
            var live   = new DraftLiveDataSource(connStr, DraftId, SelectedTemplateId.Value); // NEW

            // Generator
            var gen = new PriceBookGenerator(new IDataSource[] { legacy, live });

            var outputFileName = $"PriceBook_Draft_{DraftId}_{DateTime.Now:yyyyMMdd_HHmmss}.xlsx";
            var request = new PriceBookRequest(
                TemplatePath: templatePath,
                SourceKey: live.Key,
                ExcludeFuturePrices: ForceCurrentOnly, // true => force current-only
                OutputFileName: outputFileName
            );

            var bytes = await gen.GenerateAsync(request);
            var relPath = await SaveToWwwrootAsync(bytes, outputFileName);

            LastOutputRelativePath = relPath;
            LastMessage = $"Mode=DraftLive, Template='{templateName}', ExcludeFuturePrices={ForceCurrentOnly}";
        }
        catch (Exception ex)
        {
            ErrorMessage = ex.Message;
        }
        finally
        {
            IsBusy = false;
        }
    }

    // ----- Generate: Frozen Version -----
    private async Task GenerateFromVersionAsync()
    {
        ResetOutput();
        if (VersionId <= 0) { ErrorMessage = "Please provide a valid Version Id."; return; }

        IsBusy = true;
        try
        {
            var connStr = Config.GetConnectionString("CiiSQL10rw")
                ?? throw new InvalidOperationException("Missing connection string 'CiiSQL10rw'.");

            // Resolve Excel template from Version (joins to Template)
            var (templatePath, templateName) = await ResolveTemplatePathByVersionIdAsync(connStr, VersionId);

            // Build sources
            var legacy = new SqlDataSource(connStr);
            var snap   = new DraftVersionDataSource(connStr, VersionId); // NEW

            // Generator
            var gen = new PriceBookGenerator(new IDataSource[] { legacy, snap });

            var outputFileName = $"PriceBook_Version_{VersionId}_{DateTime.Now:yyyyMMdd_HHmmss}.xlsx";
            var request = new PriceBookRequest(
                TemplatePath: templatePath,
                SourceKey: snap.Key,
                ExcludeFuturePrices: false, // not relevant for a frozen version
                OutputFileName: outputFileName
            );

            var bytes = await gen.GenerateAsync(request);
            var relPath = await SaveToWwwrootAsync(bytes, outputFileName);

            LastOutputRelativePath = relPath;
            LastMessage = $"Mode=Version, Template='{templateName}'";
        }
        catch (Exception ex)
        {
            ErrorMessage = ex.Message;
        }
        finally
        {
            IsBusy = false;
        }
    }

    // ----- Helpers -----

    private void ResetOutput()
    {
        ErrorMessage = null;
        LastOutputRelativePath = null;
        LastMessage = null;
    }

    private async Task<(string FullPath, string TemplateName)> ResolveTemplatePathByTemplateIdAsync(string connStr, int templateId)
    {
        const string sql = @"SELECT TemplateName, ExcelFileName FROM dbo.Chap_PriceBookTemplate WHERE TemplateId = @Id;";
        await using var conn = new SqlConnection(connStr);
        await conn.OpenAsync();
        await using var cmd = new SqlCommand(sql, conn);
        cmd.Parameters.AddWithValue("@Id", templateId);
        await using var r = await cmd.ExecuteReaderAsync();
        if (!await r.ReadAsync())
            throw new InvalidOperationException($"TemplateId {templateId} not found.");
        var templateName = r.GetString(0);
        var excelName = r.GetString(1);

        var templatesRoot = Config["PriceBook:TemplatesFolder"];
        if (string.IsNullOrWhiteSpace(templatesRoot))
            throw new InvalidOperationException("Missing configuration 'PriceBook:TemplatesFolder' (folder path).");

        var fullPath = Path.Combine(templatesRoot, excelName);
        if (!System.IO.File.Exists(fullPath))
            throw new FileNotFoundException($"Excel template not found at '{fullPath}'.");
        return (fullPath, templateName);
    }

    private async Task<(string FullPath, string TemplateName)> ResolveTemplatePathByVersionIdAsync(string connStr, long versionId)
    {
        // Assumes Chap_PriceBookVersion has TemplateId FK.
        const string sql = @"
SELECT t.TemplateName, t.ExcelFileName
FROM dbo.Chap_PriceBookVersion v
JOIN dbo.Chap_PriceBookTemplate t ON t.TemplateId = v.TemplateId
WHERE v.VersionId = @Id;";

        await using var conn = new SqlConnection(connStr);
        await conn.OpenAsync();
        await using var cmd = new SqlCommand(sql, conn);
        cmd.Parameters.AddWithValue("@Id", versionId);
        await using var r = await cmd.ExecuteReaderAsync();
        if (!await r.ReadAsync())
            throw new InvalidOperationException($"VersionId {versionId} not found or missing TemplateId.");

        var templateName = r.GetString(0);
        var excelName = r.GetString(1);

        var templatesRoot = Config["PriceBook:TemplatesFolder"];
        if (string.IsNullOrWhiteSpace(templatesRoot))
            throw new InvalidOperationException("Missing configuration 'PriceBook:TemplatesFolder' (folder path).");

        var fullPath = Path.Combine(templatesRoot, excelName);
        if (!System.IO.File.Exists(fullPath))
            throw new FileNotFoundException($"Excel template not found at '{fullPath}'.");
        ResolvedVersionTemplateName = templateName;
        return (fullPath, templateName);
    }

    private async Task<string> SaveToWwwrootAsync(byte[] bytes, string fileName)
    {
        var outDir = Path.Combine(Env.WebRootPath ?? "wwwroot", "pricebooks");
        Directory.CreateDirectory(outDir);

        // Ensure unique filename
        var safeName = fileName;
        var fullPath = Path.Combine(outDir, safeName);
        int counter = 1;
        while (System.IO.File.Exists(fullPath))
        {
            var name = Path.GetFileNameWithoutExtension(fileName);
            var ext = Path.GetExtension(fileName);
            safeName = $"{name}_{counter}{ext}";
            fullPath = Path.Combine(outDir, safeName);
            counter++;
        }

        await System.IO.File.WriteAllBytesAsync(fullPath, bytes);

        // Return a relative URL (served by Static Files middleware)
        var rel = $"/pricebooks/{Uri.EscapeDataString(safeName)}";
        return rel;
    }

    private async Task FreezeAndGenerateAsync(int draftId, int templateId, string createdBy)
    {
        // 1) Build version (freeze)
        var info = await VersionService.BuildVersionAsync(draftId, templateId, createdBy, label: null);

        // 2) Resolve template full path (Templates/PriceBooks under content root)
        var templatesRoot = System.IO.Path.Combine(Env.ContentRootPath, "Templates", "PriceBooks");
        var templatePath = System.IO.Path.Combine(templatesRoot, info.ExcelFileName);
        if (!System.IO.File.Exists(templatePath))
            throw new FileNotFoundException($"Excel template not found at '{templatePath}'.");

        // 3) Generate using your existing generator + DraftVersionDataSource
        var connStr = Config.GetConnectionString("Default")!;
        var legacy = new Chapin.PriceBook.SqlDataSource(connStr);
        var snap = new Chapin.PriceBook.DraftVersionDataSource(connStr, info.VersionId);

        var gen = new Chapin.PriceBook.PriceBookGenerator(new Chapin.PriceBook.IDataSource[] { legacy, snap });

        var outputName = $"PriceBook_Version_{info.VersionId}_{DateTime.Now:yyyyMMdd_HHmmss}.xlsx";
        var req = new Chapin.PriceBook.PriceBookRequest(
            TemplatePath: templatePath,
            SourceKey: snap.Key,
            ExcludeFuturePrices: false,
            OutputFileName: outputName
        );

        var bytes = await gen.GenerateAsync(req);

        // 4) Save to desired folder (public or private)
        var generatedFolder = System.IO.Path.Combine(Env.WebRootPath ?? "wwwroot", "GeneratedPriceBooks");
        System.IO.Directory.CreateDirectory(generatedFolder);
        var outPath = System.IO.Path.Combine(generatedFolder, outputName);
        await System.IO.File.WriteAllBytesAsync(outPath, bytes);

        // Optional: show link
        var url = $"/GeneratedPriceBooks/{Uri.EscapeDataString(outputName)}";
        // ... assign to a field to show on the page
    }

    private async Task<(string TextBox4Content, string TextBox2Content)> ExtractTextFromTemplateAsync(string templatePath)
    {
        try
        {
            using var excelEngine = new ExcelEngine();
            var app = excelEngine.Excel;
            app.DefaultVersion = ExcelVersion.Xlsx;

            using var fs = new FileStream(templatePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
            var wb = app.Workbooks.Open(fs);
            var ws = wb.Worksheets[0];

            // In your template there are exactly two text boxes:
            //   tbs[0] = header ("MSD PRICE LIST …")
            //   tbs[1] = terms  ("HDA in season standard Terms: …")
            var tbs = ws.TextBoxes;

            string tb0 = tbs.Count >= 1 ? (tbs[0].Text ?? string.Empty) : string.Empty;
            string tb1 = tbs.Count >= 2 ? (tbs[1].Text ?? string.Empty) : string.Empty;

            // Convert plain text to minimal HTML for SfRichTextEditor (preserve newlines)
            static string AsHtml(string text)
            {
                if (string.IsNullOrEmpty(text)) return string.Empty;
                var encoded = System.Net.WebUtility.HtmlEncode(text);
                // wrap in a <p> and keep line breaks
                return "<p>" + encoded.Replace("\r\n", "<br/>").Replace("\n", "<br/>") + "</p>";
            }

            return (AsHtml(tb0), AsHtml(tb1));
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Failed to extract text from template: {ex.Message}";
            return (string.Empty, string.Empty);
        }
    }




    private async Task OnTemplateChangedAsync()
    {
        // Clear previous content
        TextBox4Content = string.Empty;
        TextBox2Content = string.Empty;

        if (SelectedTemplateId is int templateId)
        {
            try
            {
                var connStr = Config.GetConnectionString("CiiSQL10rw")
                    ?? throw new InvalidOperationException("Missing connection string 'CiiSQL10rw'.");

                var (templatePath, _) = await ResolveTemplatePathByTemplateIdAsync(connStr, templateId);
                (TextBox4Content, TextBox2Content) = await ExtractTextFromTemplateAsync(templatePath);
            }
            catch (Exception ex)
            {
                ErrorMessage = ex.Message;
            }
        }
    }


}
